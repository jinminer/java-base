

# 继承结构类加载过程

> ```
> 在子类装载过程中，装载程序注意它有一个基础类（即 extends 关键字要表达的意思），所以随之将其载入。
> 无论是否准备生成那个基础类的一个对象，这个过程都会发生。
> 若基础类含有另一个基础类，则另一个基础类随即也会载入，以此类推。
> 接下来，会在根基础类执行 static 初始化，再在下一个衍生类执行，以此类推。保证这个顺序是非常关键的，因为衍生类
>  的初始化可能要依赖于对基础类成员的正确初始化。
> 此时，必要的类已全部装载完毕，所以能够创建对象。
> 首先，这个对象中的所有基本数据类型都会设成它们的默认值，而将对象句柄设为 null。
> 随后会调用基础类构建器。在这种情况下，调用是自动进行的。但也完全可以用super 来自行指定构建器调用（就象在Beetle()构建器中的第一个操作一样）。
> 基础类的构建采用与衍生类构建器完全相同的处理过程。基础顺构建器完成以后，实例变量会按本来的顺序得以初始化。
> 最后，执行构建器剩余的主体部分。
> ```



# 内部类

## 字节码文件

> ```
> 由于每个类都会生成一个.class 文件，用于容纳与如何创建这个类型的对象有关的所有信息（这种信息产生
> 了一个名为 Class 对象的元类），所以大家或许会猜到内部类也必须生成相应的.class 文件，用来容纳与它
> 们的Class 对象有关的信息。这些文件或类的名字遵守一种严格的形式：先是封装类的名字，再跟随一个$，
> 再跟随内部类的名字。
> 如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用。若内部类嵌套于其他
> 内部类中，则它们的名字简单地追加在一个$以及外部类标识符的后面。
> ```



## 内部类继承

> ```
> 由于内部类构建器必须同封装类对象的一个句柄联系到一起，所以从一个内部类继承的时候，情况会稍微变
> 得有些复杂。这儿的问题是封装类的“秘密”句柄必须获得初始化，而且在衍生类中不再有一个默认的对象
> 可以连接。
> ```
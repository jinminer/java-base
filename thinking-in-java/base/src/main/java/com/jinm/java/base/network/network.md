# 网络编程

## 机器的标识

* `IP`的两种存在方式
  * (1) 大家最熟悉的`DNS`（域名服务）形式。比如支付宝的域名`alipay.com`。所以假定支付宝在自己的域内有一台名为 open 的计算机，它的域名就可以是 `open.alipay.com`（支付宝开发平台）。这正是大家向其他人发送电子函件时采用的名字，而且通常集成到一个万维网（WWW）地址里。
  * (2) 此外，亦可采用“四点”格式，亦即由点号（.）分隔的四组数字，比如202.98.32.111。
    * 不管哪种情况，`IP` 地址在内部都表达成一个由32 个二进制位（bit）构成的数字（注释①），所以`IP` 地址的每一组数字都不能超过255。

* 服务器和客户机
  * 服务器的主要任务是侦听建立连接的请求，这是由我们创建的特定服务器对象完成的。
  * 客户机的任务是试着与一台服务器建立连接，这是由我们创建的特定客户机对象完成的。

* 端口
  * 一个`IP` 地址并不足以完整标识一个服务器。这是由于在一台物理性的机器中，往往运行着多个服
    务器（程序）。
  * 一般每个端口都运行着一种服务，一台机器可能提供了多种服务，比如HTTP 和 FTP 等等
  * 端口编号是必需的一种二级定址措施。也就是说，我们请求一个特定的端口，便相当于请求与那个端口编号关联的服务。
  * 注意端口并不是机器上一个物理上存在的场所，而是一种软件抽象（主要是为了表述的方便）。
  * 系统服务保留了使用端口1 到端口 1024 的权力，所以不应让自己设计的服务占用这些以及其他任何已知正在使用的端口。

## 套接字

* 定义
  * “套接字”或者“插座”（Socket）也是一种软件形式的抽象，用于表达两台机器间一个连接的“终端”。
  * 针对一个特定的连接，每台机器上都有一个“套接字”，可以想象它们之间有一条虚拟的“线缆”。线缆的
    每一端都插入一个“套接字”或者“插座”里。
* `java`套接字对象
  * 在Java 中，我们创建一个套接字，用它建立与其他机器的连接。从套接字得到的结果是一个 `InputStream` 以及`OutputStream`（若使用恰当的转换器，则分别是 `Reader` 和 `Writer`），以便将连接作为一个 IO 流对象对待。
  * 在`java`中有两个有两个基于数据流的套接字类：
    * `ServerSocket`，服务器用它“侦听”进入的连接；
    * `Socket`，客户用它初始一次连接。
  * 网络编程
    * 编写网络应用程序时，需要特别注意自动刷新机制的使用。每次刷新缓冲区时，必须创建和发出一个数据包（数据封）。
    * 因为每次写入了输出内容后（写进out），它的缓冲区必须刷新，使信息能正式通过网络传递出去。

* 一次独一无二的因特网连接是用下述四种数据标识的：
  * `clientHost`（客户主机）
  * `clientPortNumber`（客户端口号）
  * `serverHost`（服务主机）
  *  `serverPortNumber`（服务端口号）。



## 数据报

* `TCP`
  * “传输控制协议”（`TCP`），亦称作“基于数据流的套接字”
  * 根据该协议的设计宗旨，它具有高度的可靠性，而且能保证数据顺利抵达目的地。
  * 允许重传那些由于各种原因半路“走失”的数据。而且收到字节的顺序与它们发出来时是一样的。
  * 具有非常高的开销
* `UDP`
  * “用户数据报协议”（`UDP`），它并不刻意追求数据包会完全发送出去，也不能担保它们抵达的顺序与它们发出时一样。
  * 这是一种“不可靠协议”。如果在适当的时间里没有响应，消息就会丢失。
  * 传输速度较快。
* `DatagramSocket`
  * 数据报不存在“连接”，取而代之的是一个数据报陈列出来。
  * 数据包必须知道自己来自何处，以及打算去哪里。
    * 这意味着我们必须知道每个数据报包的这些信息，否则信息就不能正常地传递。
    * 而对TCP 套接字来说，一旦我们建好了连接，便不再需要关心谁向谁“说话”——只需通过会话流来回传送数据即可。

> `TCP` 和 `UDP` 端口是相互独立的。可以在端口8080 同时运行一个 `TCP` 和 `UDP` 服务程序，两者之间不会产生冲突。



## `web`



## `JDBC`



## `RMI`

* `RMI` 对接口有着强烈的依赖。在需要创建一个远程对象的时候，我们通过传递一个接口来隐藏基层的实施细
  节。所以客户得到远程对象的一个句柄时，它们真正得到的是接口句柄。这个句柄正好同一些本地的根代码
  连接，由后者负责通过网络通信。
* 远程接口创建规则
  * (1) 远程接口必须为public 属性（不能有“包访问”；也就是说，它不能是“友好的”）。否则，一旦客户试图装载一个实现了远程接口的远程对象，就会得到一个错误。
  * (2) 远程接口必须扩展接口 `java.rmi.Remote`。
  * (3) 除与应用程序本身有关的违例之外，远程接口中的每个方法都必须在自己的`throws` 从句中声明`java.rmi.RemoteException`。
  * (4) 作为参数或返回值传递的一个远程对象（不管是直接的，还是在本地对象中嵌入）必须声明为远程接
    口，不可声明为实施类。








































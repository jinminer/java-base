# 多线程

* “进程”是指一种“自包容”的运行程序，有自己的地址空间。
* “多任务”操作系统能同时运行多个进程（程序）——但实际是由于CPU 分时机制的作用，使每个进程都能
  循环获得自己的CPU 时间片。但由于轮换速度非常快，使得所有程序好象是在“同时”运行一样。“线程”是进程内部单一的一个顺序控制流。因此，一个进程可能容纳了多个同时执行的线程。

## 线程

* 线程的四种状态：
  * (1) 新（New）：线程对象已经创建，但尚未启动，所以不可运行。
  * (2) 可运行（Runnable）：意味着一旦时间分片机制有空闲的CPU 周期提供给一个线程，那个线程便可立即开始运行。因此，线程可能在、也可能不在运行当中，但一旦条件许可，没有什么能阻止它的运行——它既没有“死”掉，也未被“堵塞”。
  * (3) 死（Dead）：从自己的 run()方法中返回后，一个线程便已“死”掉。亦可调用 stop()令其死掉，但会
    产生一个违例——属于Error 的一个子类（也就是说，我们通常不捕获它）。记住一个违例的“掷”出应当
    是一个特殊事件，而不是正常程序运行的一部分。所以不建议你使用 stop()（在Java 1.2 则是坚决反
    对）。另外还有一个destroy()方法（它永远不会实现），应该尽可能地避免调用它，因为它非常武断，根
    本不会解除对象的锁定。
  * (4) 堵塞（Blocked）：线程可以运行，但有某种东西阻碍了它。若线程处于堵塞状态，调度机制可以简单地跳过它，不给它分配任何CPU 时间。除非线程再次进入“可运行”状态，否则不会采取任何操作。

* 线程被堵塞：
  * (1) 调用sleep(毫秒数)，使线程进入“睡眠”状态。在规定的时间内，这个线程是不会运行的。
  * (2) 用suspend()暂停了线程的执行。除非线程收到 resume()消息，否则不会返回“可运行”状态。
  * (3) 用wait()暂停了线程的执行。除非线程收到 `nofify()`或者`notifyAll()`消息，否则不会变成“可运行”
    （是的，这看起来同原因2 非常相象，但有一个明显的区别是我们马上要揭示的）。
  * (4) 线程正在等候一些 IO（输入输出）操作完成。
  * (5) 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。

* 亦可调用yield()（Thread 类的一个方法）自动放弃CPU，以便其他线程能够运行。

## 总结

###  多线程缺点：

* (1) 等候使用共享资源时造成程序的运行速度变慢。
* (2) 对线程进行管理要求的额外CPU 开销。
* (3) 复杂程度无意义的加大，比如用独立的线程来更新数组内每个元素的愚蠢主意。
* (4) 漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。






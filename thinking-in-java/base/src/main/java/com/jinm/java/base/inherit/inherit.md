
# 继承

## 继承结构类加载过程

> ```
> 在子类装载过程中，装载程序注意它有一个基础类（即 extends 关键字要表达的意思），所以随之将其载入。
> 无论是否准备生成那个基础类的一个对象，这个过程都会发生。
> 若基础类含有另一个基础类，则另一个基础类随即也会载入，以此类推。
> 接下来，会在根基础类执行 static 初始化，再在下一个衍生类执行，以此类推。保证这个顺序是非常关键的，因为衍生类
>  的初始化可能要依赖于对基础类成员的正确初始化。
> 此时，必要的类已全部装载完毕，所以能够创建对象。
> 首先，这个对象中的所有基本数据类型都会设成它们的默认值，而将对象句柄设为 null。
> 随后会调用基础类构建器。在这种情况下，调用是自动进行的。但也完全可以用super 来自行指定构建器调用（就象在Beetle()构建器中的第一个操作一样）。
> 基础类的构建采用与衍生类构建器完全相同的处理过程。基础顺构建器完成以后，实例变量会按本来的顺序得以初始化。
> 最后，执行构建器剩余的主体部分。
> ```

## 构造器的调用顺序
>基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，使每个基础类使用的构建器都
 能得到调用。之所以要这样做，是由于构建器负有一项特殊任务：检查对象是否得到了正确的构建。一个衍
 生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private 属性）。只有基础类的
 构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。所以，必须令所有构建器都得到调
 用，否则整个对象的构建就可能不正确。那正是编译器为什么要强迫对衍生类的每个部分进行构建器调用的
 原因。在衍生类的构建器主体中，若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用
 默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织
 一个默认构建器）。

>对于一个复杂的对象，构建器的调用遵照下面的顺序：
  (1) 调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生
  类，等等。直到抵达最深一层的衍生类。
  (2) 按声明顺序调用成员初始化模块。
  (3) 调用衍生构建器的主体。

## 构造器内部的多形性方法行为

>初始化的实际过程是这样的：
 (1) 在采取其他任何操作之前，为对象分配的存储空间初始化成二进制零。
 (2) 调用基础类构建器。此时，如果基类构造器调用了某个抽象方法，则子类中具体的该该方法的实先会得到调用（的确是在子类构建器调用之前），
     此时会发现子类中被该方法调用且在方法外被初始化的属性值为默认值，这是由于步骤(1)造成的。
 (3) 按照原先声明的顺序调用成员初始化代码。
 (4) 调用衍生类构建器的主体。
>注意：
>采取这些操作要求有一个前提，那就是所有东西都至少要初始化成零（或者某些特殊数据类型与“零”等价
 的值），而不是仅仅留作垃圾。其中包括通过“合成”技术嵌入一个类内部的对象句柄。如果假若忘记初始
 化那个句柄，就会在运行期间出现违例事件。

## 构建器设计规则
> 设计构建器时一个特别有效的规则是：用尽可能简单的方法使对象进入就绪状态；如果可能，避免调
  用任何方法。在构建器内唯一能够安全调用的是在基础类中具有final 属性的那些方法（也适用于private
  方法，它们自动具有final 属性）。这些方法不能被覆盖，所以不会出现上述潜在的问题。

## 运行期类型标识
> 在运行期间对类型进行检查的行为叫作“运行期类型标识”,这个检查行为是自动进行的

# 异常
## Throwable
> Java 包含了一个名为Throwable 的类，它对可以作为违例“掷”出的所有东西进行了描述。Throwable 对象
  有两种常规类型（亦即“从Throwable 继承”）。
> Error 代表**编译期**和**系统错误**，我们一般不必特意捕获它们（除在特殊情况以外）。
> Exception 是可以从任何标准 **Java 库的类方法中“掷”出的基本类型**。此外，它们亦可从我们自己的方法以及运行期偶发事件中“掷”出。

## 异常限制
> 覆盖一个方法时，只能产生已在方法的基础类版本中定义的违例。这是一个重要的限制，因为它意味着与基
  础类协同工作的代码也会自动应用于从基础类衍生的任何对象（这属于基本的 OOP 概念），其中包括
  异常。

## finally
* 对象清除
> 大多数时候，发生异常时，对象的清除操作都会安全进行。
> 但在构建器中却是一个大问题。构建器将对象置于一个安全的起始状态，但它可能执行一些
  操作——如打开一个文件。除非用户完成对象的使用，并调用一个特殊的清除方法，否则那些操作不会得到
  正确的清除。若从一个构建器内部“掷”出一个违例，这些清除行为也可能不会正确地发生。
* 基于finally的兜底清除
> finally每次都会执行清除代码——即使我们在清除方法运行之前不想执行清除代码。因此，假如真的用 finally 进
  行清除，必须在构建器正常结束时设置某种形式的标志。而且只要设置了标志，就不要执行 finally 块内的
  任何东西。由于这种做法并不完美（需要将一个地方的代码同另一个地方的结合起来），所以除非特别需
  要，否则一般不要尝试在finally 中进行这种形式的清除。

* 安全地进行对象清除
```java
catch(Exception e) {
     // All other exceptions must close it
     try {
        in.close();
     } catch(IOException e2) {
        System.out.println("in.close() unsuccessful");
     }
     throw e;
 } finally {
    // Don't close it here!!!
 }
```
## 异常开发准则
> 用违例做下面这些事情：
  (1) 解决问题并再次调用造成违例的方法。
  (2) 平息事态的发展，并在不重新尝试方法的前提下继续。
  (3) 计算另一些结果，而不是希望方法产生的结果。
  (4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。
  (5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。
  (6) 中止程序执行。
  (7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。
  (8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性）

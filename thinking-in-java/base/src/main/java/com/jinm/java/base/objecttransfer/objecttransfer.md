# 传递和返回对象

* Java 中每个对象（除基本数据类型以外）的标识符都属于指针的一种。
* 这种指针叫做“句柄”，相当于一种“安全指针”，但没有传统指针的麻烦。

## 传递句柄

* 将句柄传递进入一个方法时，指向的仍然是相同的对象。

* 多个句柄都试图指向同一个对象

## 本地副本

* 对象/句柄
  * 参数传递过程中会自动产生别名问题
  * 不存在本地对象，只有本地句柄
  * 句柄有自己的作用域，而对象没有
  * 对象的“存在时间”在Java 里不是个问题
  * 没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用）

### 按值传递

“按值传递”以及它的含义取决于如何理解程序的运行方式。

* 基本类型数据
  * 若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。
* 对象
  * 一个句柄传递进入方法，得到的是句柄的副本。
  * 即对象却是按引用传递的

### 克隆对象

* 定义

  * 若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见
    的一种用途。
  * 若决定制作一个本地副本，只需简单地使用 clone()方法即可。Clone 是“克隆”的意思，即制作完全一模一样的副本。
  * 这个方法在基础类Object 中定义成“protected”（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为“public”模式。

  * clone()方法产生了一个Object，后者必须立即重新造型为正确类型。

* 浅克隆
  * clone()方法不能自动尝试克隆复合对象(内部包含其他对象的句柄)内包含的每个对象——由于别名问题，复合对象和克隆的复合对象都包含了相同的对象。
  * 浅克隆只复制了一个对象的“表面”部分。实际对象除包含这个“表面”以外，还包括句柄指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是“对象网”或“对象关系网”的由来。若能复制下所有这张网，便叫作“全面复制”或者“深层复制”。
  * 浅克隆复合对象后，如果复合对象内部的属性句柄所指向的对象修改了，克隆后的复合对象内部的对象句柄所指向的对象也会修改，因为浅克隆后，克隆对象和源克隆对象内部的对象句柄指向的是同一个对象

### 使对象具备克隆能力

尽管克隆方法是在所有类最基本的 Object 中定义的，但克隆仍然不会在每个类里自动进行。如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行：

* 使用protected 时的技巧

  * 为避免我们创建的每个类都默认具有克隆能力，clone()方法在基础类Object 里得到了“保留”（设为
    protected）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用 clone()（尽管那样做在某些情况下特别有用，比如用多形性的方式克隆一系列对象）。

  * 克隆时要注意的两个关键问题是：几乎肯定要调用`super.clone()`，以及注意将克隆设为 public。
  * 一旦对象变得可以克隆，从它衍生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其“关闭”克隆能力。在从我们的类继承的任何场合，clone()方法都是可以使用的，因为Java 不可能在衍生
    之后反而缩小方法的访问范围。

* 实现`Cloneable` 接口

  * 这个接口是空的：`interface Cloneable {}` 
  * `Cloneable` interface 存在的原因：
    * （1）可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用`instanceof` 关键字调查句柄是否确实同一个能克隆的对象连接：
      `if(myHandle instanceof Cloneable) // ...` 
    * （2）可能不愿所有对象类型都能克隆。所以`Object.clone()`会验证一个类是否真的是实
      现了`Cloneable` 接口。

* 示例

  ```java
  class MyObject implements Cloneable {
      
   	int i;
  	MyObject(int ii) { i = ii; }
      
   public Object clone() {
   	Object o = null;
   	try {
   		o = super.clone();
   	} catch (CloneNotSupportedException e) {
   		System.out.println("MyObject can't clone");
   	}
   	return o;
   }
      
   public String toString() {
   	return Integer.toString(i);
   }
      
  }
  
  ```

  

* 克隆机制
  * `Object.clone()`会检查原先的对象有多大，再为新对象腾出足够多的内存，将所有二进制位从原来的对象复制到新对象。这叫作“按位复制”。
  * 在`Object.clone()`正式开始操作前，首先会检查一个类是否 `Cloneable`，即是否具有克隆能力——换言之，它是否实现了 `Cloneable` 接口。若未实现，`Object.clone()`就掷出一个 `CloneNotSupportedException` 违例，指出我们不能克隆它。

> Java 对“是否等价”的测试并不对所比较对象的内部进行检查，从而核实它们的值是否相同。==和!=运算符只是简单地对比句柄的内容。若句柄内的地址相同，就认为句柄指向同样的对象，所以认为它们是“等价”的。



### `Object.clone()`

* 调用`Object.clone()`时，实际发生的事情
  * 根类中的 `clone()`方法负责建立正确的存储容量，并通过“按位复制”将二进制位从原始对象中复制到新对象的存储空间。
  * 也就是说，它并不只是预留存储空间以及复制一个对象——实际需要调查出欲复制之对象的准确大小，然后复制那个对象。
  * 由于所有这些工作都是在由根类定义之`clone()`方法的内部代码中进行的（根类并不知道要从自己这里继承出去什么），所以这个过程需要用`RTTI` 判断欲克隆的对象的实际大小。
  * 采取这种方式，`clone()`方法便可建立起正确数量的存储空间，并对那个类型进行正确的按位复制。

### 克隆合成对象

* 深克隆
  * 为了对复合对象进行深层复制，重写`clone()`方法时必须同时克隆复合对象内的句柄。
  * 在类的继承结构中，如果子类只有基本类型属性，不必覆盖父类的`clone()`。
    * 子类在调用父类的`clone()` 方法时，最终会调用`Object.clone()`，并判断出当前操作的衍生类，会自动对衍生类中的基本类型属性，对衍生类的二进制进行复制
    * 当衍生类中新增的属性包含对象句柄时，如果要进行深克隆，衍生类必须覆写父类的`clone()`，以保证新增句柄对象的克隆复制

### 序列化/克隆

* 对比
  * 代码层面
    * 序列化：代码量少，实现过程较为简便
    * 克隆：代码量大，需要覆写方法，并且深克隆时，要冲复合对象的对象句柄属性
  * 性能
    * 序列化：
      * 运行时，实际做的工作较多，运行时间较长
      * 而且运行结果不稳定，每次运行时间都不尽相同
    * 克隆
      * 运行时间较短
      * 运行结果稳定，每次运行时间都相同

* `jdk`演进

  > 由于Java 在因特网程序设计广泛应用，人们提出了安全问题，而且理所当然，这些问题与使用对象有关，我们不愿望任何人克隆自己的保密对象。
  >
  > 所以我们最后看到的是为原来那个简单、直观的方案添加的大量补丁：`clone()`在`Object` 里被设置成`“protected”`。必须将其覆盖，并使用`“implement Cloneable”`，同时解决违例的问题。



### 控制克隆

* 防止克隆

  > 将类设为final，从而防止克隆。
  >
  > 若clone()尚未被我们的任何一个上级类覆盖，这一设想便不会成功。
  > 若已被覆盖，那么再一次覆盖它，并“掷”出一个 `CloneNotSupportedException`（克隆不支持）违例。
  >
  > 为担保克隆被禁止，将类设为final 是唯一的办法。除此以外，一旦涉及保密对象或者遇到想对创建的对象数量进行控制的其他情况，应该将所有构建器都设为private，并提供一个或更多的特殊方法来创建对象。

* 类能够被克隆的依据
  * (1) 实现`Cloneable` 接口
  * (2) 覆盖`clone()`
  * (3) 在自己的`clone()`中调用 `super.clone()`
  * (4) 在自己的`clone()`中捕获违例



## 只读类
















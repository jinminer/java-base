# Creating and Destroying Objects

创建、销毁对象

## 考虑用静态工厂方法代替构造函数

### 定义

* 返回一个类的实例的静态方法
* 代替类的公有构造函数
* 静态工厂方法(static factory method)和设计模式中的工厂方法模式(factory method pattern)并不直接对应

### 优点

* 1-有具体的方法名称
  * 构造函数重载，会导致调用者陷入方法选择的困境，只能借助于的对应的参考文档来避免这些问题
  * 静态工厂方法见名知意、辨识度高，对应的客户端代码也更易阅读，调用者使用也更加顺手
  * 当类需要有多个签名相似构造函数时，应该考虑使用静态工厂方法
* 2-不需要每次调用时都创建一个新对象
  * 结合使用场景，对于那些不可变类，可以使用预先构建好的 例，或者将 构建好的 缓存 来， 行重复利用，从而避免创建不必要的重复对象
  * 类似于设计模式中的享元模式(flyweight)，对于那些需要经常请求创建建相同的对象，并且创建对象的代价很高的程序，这样的设计可以极大地提升程序的性能
  * instance-controlled(实例受控的类)
    * 静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在
    * 确保类单例(singleton)，如枚举类(`enum`)
* 3-可以返回其返回类型的任何子类型的对象
  * 这种灵活性的一个应用是： `API` 可以返回对象而不需要公开它的类
  * 这种方式隐藏实现类会使 `API` 非常紧凑。 这种技术适用于基于接口的框架，其中接口为静态工厂方法提供自然返回类型。
  * `Java Collections Framework API` 集合接口有 45 个工具类(不可实例化的伴生类)实现
    * 这种静态工厂方法，要求客户端通过接口来引用被返回的对象， 而不是通过它的实现类来引用被返回的对象，这是一种良好的习惯
* 4-返回对象的类可以根据输入参数的不同而不同
* 5-方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在
  * 服务提供者框架(`Service Provider Framework`)
    * 定义：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个 实现中解稠出来
    * 组件：
      * 服务接口(`Service Interface`) - 由提供者实现
      * 提供者注册 `API(Provider Registration API)` - 是提供者用来注册实现的
      * 服务访问 `API (Service Access API)`  - 这是客户端用来获取服务的实例服务访问 `API` 是客户端用来指定某种选择实现的条件，即服务访问 `API` 允许客户指定选择实现的标准
  * 例如 `JDBC`(Java 数据库连接）`API` 
    * `Connection` 扮演服务接口的一部分， `DriverManager.registerDriver` 提供程序注册 `API`、 `DriverManager.getConnection` 是服务访问 `API`， `Driver` 是服务提供者接口。

### 缺点

* 1- 类如果不含公有的或者受保护的构造器，就不能被子类化
  * 提倡使用复合(`omposition`)，而避免继承结构，这也是不可变类型所需要的
* 程序员很难找到它们



## 当构造方法参数过多时要考虑使用构建器

### 建造者模式(Builder)

* 规则
  * 它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个 `builder`对象
  * 然后客户端在`builder`对象上调用类似`javaBeans`的`setter`方法，来设置每个相关的可选参数
  * 最后客户端调用无参的`build`方法来生成不可变的对象
  * 这个`build`通常是它构建的类的静态成员类
    * 如果是非静态内部类，则需要被构建类生成一个对象去初始化，这样构建类的初始化操作并没有交由`builder`对象去做，不能达到构建类不可变的效果
  * 另外，可以在 `builder` 的构造器和方法中检查被构建类参数的有效性


















# Creating and Destroying Objects

创建、销毁对象

## 考虑用静态工厂方法代替构造函数

### 定义

* 返回一个类的实例的静态方法
* 代替类的公有构造函数
* 静态工厂方法(static factory method)和设计模式中的工厂方法模式(factory method pattern)并不直接对应

### 优点

* 1-有具体的方法名称
  * 构造函数重载，会导致调用者陷入方法选择的困境，只能借助于的对应的参考文档来避免这些问题
  * 静态工厂方法见名知意、辨识度高，对应的客户端代码也更易阅读，调用者使用也更加顺手
  * 当类需要有多个签名相似构造函数时，应该考虑使用静态工厂方法
* 2-不需要每次调用时都创建一个新对象
  * 结合使用场景，对于那些不可变类，可以使用预先构建好的 例，或者将 构建好的 缓存 来， 行重复利用，从而避免创建不必要的重复对象
  * 类似于设计模式中的享元模式(flyweight)，对于那些需要经常请求创建建相同的对象，并且创建对象的代价很高的程序，这样的设计可以极大地提升程序的性能
  * instance-controlled(实例受控的类)
    * 静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在
    * 确保类单例(singleton)，如枚举类(`enum`)
* 3-可以返回其返回类型的任何子类型的对象
  * 这种灵活性的一个应用是： `API` 可以返回对象而不需要公开它的类
  * 这种方式隐藏实现类会使 `API` 非常紧凑。 这种技术适用于基于接口的框架，其中接口为静态工厂方法提供自然返回类型。
  * `Java Collections Framework API` 集合接口有 45 个工具类(不可实例化的伴生类)实现
    * 这种静态工厂方法，要求客户端通过接口来引用被返回的对象， 而不是通过它的实现类来引用被返回的对象，这是一种良好的习惯
* 4-返回对象的类可以根据输入参数的不同而不同
* 5-方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在
  * 服务提供者框架(`Service Provider Framework`)
    * 定义：多个服务提供者实现一个服务，系统为服务提供者的客户端提供多个实现，并把它们从多个 实现中解稠出来
    * 组件：
      * 服务接口(`Service Interface`) - 由提供者实现
      * 提供者注册 `API(Provider Registration API)` - 是提供者用来注册实现的
      * 服务访问 `API (Service Access API)`  - 这是客户端用来获取服务的实例服务访问 `API` 是客户端用来指定某种选择实现的条件，即服务访问 `API` 允许客户指定选择实现的标准
  * 例如 `JDBC`(Java 数据库连接）`API` 
    * `Connection` 扮演服务接口的一部分， `DriverManager.registerDriver` 提供程序注册 `API`、 `DriverManager.getConnection` 是服务访问 `API`， `Driver` 是服务提供者接口。

### 缺点

* 1- 类如果不含公有的或者受保护的构造器，就不能被子类化
  * 提倡使用复合(`omposition`)，而避免继承结构，这也是不可变类型所需要的
* 程序员很难找到它们



## 当构造方法参数过多时要考虑使用构建器

### 建造者模式(Builder)

* 规则
  * 它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个 `builder`对象
  * 然后客户端在`builder`对象上调用类似`javaBeans`的`setter`方法，来设置每个相关的可选参数
  * 最后客户端调用无参的`build`方法来生成不可变的对象
  * 这个`build`通常是它构建的类的静态成员类
    * 如果是非静态内部类，则需要被构建类生成一个对象去初始化，这样构建类的初始化操作并没有交由`builder`对象去做，不能达到构建类不可变的效果
  * 另外，可以在 `builder` 的构造器和方法中检查被构建类参数的有效性

* 协变返回类型（covariant return typing）
  * 其一个子类的方法被声明为返回在超类中声明的返回类型的子类型
  * 它允许客户端使用这些 builder，而不需要强制转换。

* 优点
  * builder 可以有多个可变参数，因为每个参数都是在它自己的方法中指定的
    * builder 将传递给多个调用的参数聚合到单个属性中
  * Builder 模式非常灵活。 
    * 单个 builder 可以重复使用来构建多个对象。 
    * builder 的参数可以在构建方法的调用之间进行调整，以改变创建的对象。
    * builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。

* 缺点
  * 为了创建对象，首先必须创建它的 builder
    * 虽然创建这个 builder 的成本在实践中不太可 能被注意到，但在性能关键的情况下可能会出现问题。
  * builder 模式比伸缩构造方法模式更冗长，因此只有在 有足够的参数时才值得使用它，比如四个或更多。



## 使用私有构造方法或枚类实现 Singleton 属性

### 单例模式 Singleton

* 定义
  * 单例是一个仅实例化一次的类
  * 单例对象通常表示无状态对象，如函数或一个本质上唯一的系统组件。
* 基于保持构造方法私有和导出公共静态成员以提供对唯一实例的访问
  * 两种类型
    * (1)成员是 final 修饰的属性
    * (2)公共成员是一个静态的工厂方法
      * 线程不安全：多线程场景下，可能会有多个实例

* 保护单例
  * 为了维护单例的保证，声明所有的实例属性为 `transient` ，并提供一个 `readResolve` 方法；否则，每 当序列化实例被反序列化时，就会创建一个新的实例，在我们的例子中，导致出现新的实例
  * 绝对单例
    * 声明单一元素的枚举类
      * 单一元素枚举类通常是实现单例的最佳方式。
      * 这种方式类似于公共属性方法，但更简洁，提供了免费的序列化机制，并提供了针对多个实例化的坚固保证，即 使是在复杂的序列化或反射攻击的情况下。
    * 注意，如果单例必须继承 Enum 以外的父类 (尽管可以声明一个 Enum 来实现接口)，那么就不能使用这种方法。



## 使用私有构造方法执行非实例化

通过包含一个私有构造方法来实现类的非实例化，并在该构造函数中抛出异常，保证不被实例化，包括子类。



## 依赖注入优于硬连接资源(hardwiring resources)

### 依赖项注入（dependency injection）

* 定义
  * 对于底层资源参数化的类，通过在创建新实例时将资源传递到构造方法中(该资源属性为`final`型)
  * 虽然类中只声明一 个资源(定义了一个属性)，但是依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性，因此多个 客户端可以共享依赖对象（假设客户需要相同的底层资源）。
  * 将资源属性声明为`final`型，可以有效防止象对属性进行重新赋值



## 避免创建不必要的对象

* 规则
  * 对于经常调用的，不可变的，创建消耗较大的对象，可进行静态初始化，并用`final`修饰，使其只初始化一次
  * 优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。
* 注意
  * 使用构造方法创建和回收小的对 象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。 创建额外的对象以增强程序的清晰 度，简单性或功能性通常是件好事。
  * 除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。



## 消除过期的对象引用

* 清除过期引用
* 防止对象长期占用内存，无法被jvm回收，导致内存泄漏



## 避免使用 Finalizer 和 Cleaner 机制

* Finalizer 和 Cleaner 机制的一个缺点是不能保证他们能够及时执行
* Finalizer 机制的另一个问题是在执行 Finalizer 机制过程中，未捕获的异常会被忽略，并且该对象的 Finalizer 机制也会终止



## 使用 try-with-resources 语句替代 try-finally 语句

* 在处理必须关闭的资源时，使用 try-with-resources 语句替代 try-finally 语句。 
* 生成的代码更简洁， 更清晰，并且生成的异常更有用。 
* try-with-resources 语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用 try-finally 语句实际上是不可能的。
* 在 try-finally 语句中，如果finally块中抛出了异常，则打印的异常信息会覆盖try块中的异常信息，导致调试困难












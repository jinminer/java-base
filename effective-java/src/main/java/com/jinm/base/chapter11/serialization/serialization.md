# 序列化

## 优先选择 Java 序列化的替代方案



## 非常谨慎地实现 `Serializable`

* 实现序列化的代价
  * 一旦类的实现被发布，它就会降低更改该类实现的灵活性
  * 增加了出现 bug 和安全漏洞的可能性
  * 增加了与发布类的新版本相关的测试负担



## 考虑使用自定义的序列化形式



## 保护性的编写 `readObject` 方法



## 对于实例控制，枚举类型优于 `readResolve`



## 考虑用序列化代理代替序列化实例

* 序列化代理模式（`seralization proxy pattern`）
  * 首先，为可序列化的类设计一个私有的静态嵌套类，精确地表示外围类的逻辑状态。
  * 这个嵌套类被称为序列化代理（`seralization proxy`），它应该有一个单独的构造器，其参数类型就是那个外围类。
  * 这个构造器只是从它的参数中复制数据：它不需要进行任何一致性检验或者保护性拷贝。
  * 从设计的角度看，序列化代理的默认序列化形式是外围类最好的序列化形式。
  * 外围类及其序列代理都必须声明实现 `Serializable` 接口。






























# 异常

## 只针对异常的情况下才使用异常



## 对可恢复的情况使用受检异常，对编程错误使用运行时异常

* 概念

  * Java 程序设计语言提供了三种 `throwable`：受检异常（`checked exceptions`）、运行时异常（`runtime exceptions`）和错误（`errors`）。

  * 受检异常
    * 如果期望调用者能够合理的恢复程序运行，对于这种情况就应该使用受检异常。
    * 通过抛出受检异常，强迫调用者在一个 catch 子句中处理该异常，或者把它传播出去。因此，方法中声明要抛出的每个受检异常都是对 `API` 用户的一个潜在提示：与异常相关联的条件是调用这个方法一种可能结果。
  * 非受检的 `throwable`：
    * 分类
      * 运行时异常
      * 错误。
    * 在行为上两者是等同的：它们都是不需要也不应该被捕获的`throwable`。如果程序抛出非受检异常或者错误，往往属于不可恢复的情形，程序继续执行下去有害无益。如果程序没有捕捉到这样的 `throwable`，将会导致当前线程中断（halt），并且出现适当的错误消息。

* 规则
  * 对于可恢复的情况，要抛出受检异常；
  * 对于程序错误，就要抛出运行时异常。不确定是否可恢复，就跑出为受检异常。
  * 不要定义任何既不是受检异常也不是运行异常的抛出类型。
  * 要在受检异常上提供方法，以便协助程序恢复。



## 避免不必要的使用受检异常

* 抛出受检异常的方法不能直接在 Stream 中使用



## 优先使用标准的异常

* 异常是可序列化的。
  * 这也正是“如果没有非常正当的理由，千万不要自己编写异常类”的原因。



## 抛出与抽象对应的异常

* 异常转译 （exception translation）
  * 更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为异常转译 （exception translation）

* 异常链（exception chaining）
  * 低层的异常（原因）被传到高层的异常，高层的异常提供访问方法 (`Throwable` 的`getCause` 方法）来获得低层的异常
  * 如果低层的异常对于调试导致高层异常的问题非常有帮助，使用异常链就很合适。
  * 高层异常的构造器将原因传到支持链 `(chaining-aware)` 的超级构造器，因此它最终将被传给 Throw able 的其中一个运行异常链的构造器，例如 `Throwable(Throwable)`
  * 优势
    * 允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析



## 每个方法抛出的异常都需要创建文档



## 在细节消息中包含失败一捕获信息



## 保持失败原子性

* 概念
  * 失败原子性 （failure atomic）

* 获得失败原子性的办法
  * 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。
  * 在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。
  * 是编写一段恢复代码 （recovery code），由它来拦截操作过程中发生的失败，以及便对象回滚到操作开始之前的状态上。这种办法主要用于永久性的 (基于磁盘的) 数据结构。



## 不要忽略异常




























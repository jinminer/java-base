# 通用编程

## 最小化局部变量的作用域



## for-each 循环优于传统 for 循环



## 了解并使用库



## 若需要精确答案就应避免使用 float 和 double 类型



## 基本数据类型优于包装类

* 概念
  * 基本类型和包装类型之间有三个主要区别。
    * 首先，基本类型只有它们的值，而包装类型具有与其值不同的标识。换句话说，两个包装类型实例可以具有相同的值和不同的标识。
    * 第二，基本类型只有全功能值，而每个包装类型除了对应的基本类型的所有功能值外，还有一个非功能值，即 null。
    * 最后，基本类型比包装类型更节省时间和空间。

* 包装类适用范围
  * 不能将基本类型放在集合中，因此必须使用包装类型。
  * 在参数化类型和方法中，必须使用包装类型作为类型参数，因为 Java 不允许使用基本类型。
  * 在进行反射方法调用时，必须使用包装类型
* 注意
  * 程序将基本类型装箱时，可能会导致代价高昂且不必要的对象创建
  * 自动装箱减少了使用包装类型的冗长，但没有减少危险。 程序使用 == 操作符比较两个包装类型时，它会执行标识比较，会得到错误结果



## 当使用其他类型更合适时应避免使用字符串



## 当心字符串连接引起的性能问题

* 使用字符串串联运算符重复串联 n 个字符串需要n 的平方级时间。
  * 当连接两个字符串时，将复制这两个字符串的内容。
* 要获得能接受的性能，请使用 `StringBuilder` 代替 `String` 来存储正在构建的语句



## 通过接口引用对象



## 接口优于反射

* 概念
  * 核心反射机制 `java.lang.reflect` 提供对任意类的编程访问。给定一个 Class 对象，你可以获得Constructor、Method 和 Field 实例，分别代表了该 Class 实例所表示的类的构造器、方法和字段。这些对象提供对类
    的成员名、字段类型、方法签名等的编程访问。
  * 反射允许一个类使用另一个类，即使在编译前者时后者并不存在。

* 反射的代价
  * 你失去了编译时类型检查的所有好处， 包括异常检查。如果一个程序试图反射性地调用一个不存在的或不可访问的方法，它将在运行时失败，除非你采取了特殊的预防措施。
  * 执行反射访问所需的代码既笨拙又冗长。 写起来很乏味，读起来也很困难。
  * 性能降低。 反射方法调用比普通方法调用慢得多。到底慢了多少还很难说，因为有很多因素在起作用。

* 反射适用场景
  * 对于许多程序，它们必须用到在编译时无法获取的类，在编译时存在一个适当的接口或超类来引用该类。如果是这种情况，可以用反射方式创建实例，并通过它们的接口或超类正常地访问它们。



## 明智审慎地本地方法



## 明智审慎地进行优化



## 遵守被广泛认可的命名约定

* 类型参数
  * 类型参数名通常由单个字母组成。
  * 最常见的是以下五种类型之一：
    * T 表示任意类型，
    * E 表示集合的元素类型，
    * K和 V 表示 Map 的键和值类型，
    * X 表示异常。
    * 函数的返回类型通常为 R。
    * 任意类型的序列可以是 T、U、V 或 `T1、T2、T3`。















